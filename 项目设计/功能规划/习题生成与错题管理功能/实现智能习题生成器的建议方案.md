# 实现智能习题生成器功能

基于你现有的项目结构，实现智能习题生成器功能需要以下几个步骤：

## 1. 创建数据模型

首先，需要创建习题相关的模型：

```python
# server/app/models/exercise.py
from enum import IntEnum
from tortoise import fields, models

class ExerciseType(IntEnum):
    """习题类型枚举"""
    CHOICE = 1      # 选择题
    FILL_BLANK = 2  # 填空题
    SHORT_ANSWER = 3 # 简答题

class CourseExercise(models.Model):
    """课程习题模型"""
    id = fields.IntField(pk=True)
    title = fields.CharField(max_length=200, description="习题标题")
    content = fields.TextField(description="习题内容")
    answer = fields.TextField(description="参考答案")
    explanation = fields.TextField(null=True, description="解析")
    type = fields.IntEnumField(ExerciseType, description="习题类型")
    
    # 存储选择题选项，JSON格式
    options = fields.JSONField(null=True, description="选择题选项")
    
    # 关联课程
    course = fields.ForeignKeyField(
        "models.Course", related_name="course_exercises",
        on_delete=fields.CASCADE, description="所属课程"
    )

    # 关联通知(可选)
    notification = fields.ForeignKeyField(
        "models.CourseNotification", related_name="exercises",
        on_delete=fields.SET_NULL, null=True, description="关联通知"
    )

    # 创建者（教师）
    creator = fields.ForeignKeyField(
        "models.Teacher", related_name="created_exercises",
        on_delete=fields.SET_NULL, null=True, description="创建者"
    )

    created_at = fields.DatetimeField(auto_now_add=True, description="创建时间")
    updated_at = fields.DatetimeField(auto_now=True, description="更新时间")

    class Meta:
        table = "course_exercises"
        table_description = "课程习题表"
```

## 2. 更新模型导入文件

在 `server/app/models/__init__.py` 中添加新模型：

```python
from .course_exercise import CourseExercise, ExerciseType

# 更新导出列表
__all__ = [
    'Course', 'CourseStudent', 'CourseStatus',
    'Student',
    'Teacher',
    'Admin',
    'CourseNotification', 'CourseNotificationRead', 'NotificationType',
    'CourseExercise', 'ExerciseType'
]
```

## 3. 创建习题生成服务

```python
# server/app/services/exercise_generator_rt.py
import openai
from typing import List, Dict, Any, Optional
from app.core.config import settings
from app.models import CourseExercise, ExerciseType, Course, Teacher

class ExerciseGenerator:
    """习题生成器服务"""
    
    def __init__(self):
        # 配置OpenAI API密钥
        openai.api_key = settings.OPENAI_API_KEY
        
    async def generate_exercises(
        self, 
        course_id: int,
        teacher_id: int,
        content: str, 
        exercise_types: List[ExerciseType] = None,
        count: int = 5,
        notification_id: Optional[int] = None
    ) -> List[CourseExercise]:
        """
        根据内容生成习题
        
        参数:
            course_id: 课程ID
            teacher_id: 教师ID
            content: 教学内容/知识点
            exercise_types: 习题类型列表
            count: 生成习题数量
            notification_id: 关联的通知ID
            
        返回:
            List[CourseExercise]: 生成的习题列表
        """
        if exercise_types is None:
            exercise_types = [ExerciseType.CHOICE, ExerciseType.FILL_BLANK]
            
        # 获取课程和教师
        course = await Course.get(id=course_id)
        teacher = await Teacher.get(id=teacher_id)
        
        # 构建提示词
        prompt = self._build_prompt(content, exercise_types, count)
        
        # 调用OpenAI API
        response = await self._call_openai_api(prompt)
        
        # 解析生成结果
        exercise_data = self._parse_response(response)
        
        # 保存到数据库
        exercises = []
        for data in exercise_data:
            exercise = await CourseExercise.create(
                title=data["title"],
                content=data["content"],
                answer=data["answer"],
                explanation=data.get("explanation"),
                type=data["type"],
                options=data.get("options"),
                course=course,
                creator=teacher,
                notification_id=notification_id
            )
            exercises.append(exercise)
            
        return exercises
    
    def _build_prompt(self, content: str, exercise_types: List[ExerciseType], count: int) -> str:
        """构建提示词"""
        type_names = {
            ExerciseType.CHOICE: "选择题",
            ExerciseType.FILL_BLANK: "填空题",
            ExerciseType.SHORT_ANSWER: "简答题"
        }
        
        type_str = "、".join([type_names[t] for t in exercise_types])
        
        return f"""根据以下教学内容，生成{count}道{type_str}，要求:
1. 每道题目包含题目内容、答案和解析
2. 选择题需提供4个选项(A、B、C、D)
3. 题目难度适中，考察对知识点的理解
4. 返回JSON格式，包含类型、题目、选项、答案和解析字段

教学内容:
{content}

请按以下JSON格式返回:
[
  {{
    "type": 1或2或3(1=选择题,2=填空题,3=简答题),
    "title": "题目标题",
    "content": "题目内容",
    "options": ["选项A", "选项B", "选项C", "选项D"], // 选择题必须
    "answer": "正确答案",
    "explanation": "题目解析"
  }},
  // 其他题目...
]
"""
    
    async def _call_openai_api(self, prompt: str) -> str:
        """调用OpenAI API"""
        try:
            response = await openai.ChatCompletion.acreate(
                model="gpt-3.5-turbo",
                messages=[
                    {"role": "system", "content": "你是一位专业的教育教师，擅长出题。"},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.7,
                max_tokens=2000
            )
            return response.choices[0].message.content
        except Exception as e:
            print(f"调用OpenAI API失败: {e}")
            return "[]"
    
    def _parse_response(self, response: str) -> List[Dict[str, Any]]:
        """解析API返回结果为习题数据列表"""
        import json
        import re
        
        try:
            # 提取JSON部分
            json_match = re.search(r'\[\s*{.*}\s*\]', response, re.DOTALL)
            if json_match:
                json_str = json_match.group(0)
                return json.loads(json_str)
            else:
                return []
        except Exception as e:
            print(f"解析响应失败: {e}")
            return []
```

## 4. 添加API路由

```python
# server/app/api/endpoints/exercises.py
from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, status
from app.core.auth import get_current_teacher
from app.models import CourseExercise, ExerciseType, Teacher
from app.services.teacher.exercise_generator_svc import ExerciseGenerator
from app.schemas.exercise import (
    ExerciseCreate,
    ExerciseResponse,
    ExerciseGenerateRequest
)

router = APIRouter()
exercise_generator = ExerciseGenerator()


@router.post("/{course_id}/generate", response_model=List[ExerciseResponse])
async def generate_exercises(
        course_id: int,
        request: ExerciseGenerateRequest,
        current_user: Teacher = Depends(get_current_teacher)
):
    """生成课程习题"""
    try:
        exercises = await exercise_generator.generate_exercises(
            course_id=course_id,
            teacher_id=current_user.id,
            content=request.content,
            exercise_types=request.exercise_types,
            count=request.count,
            notification_id=request.notification_id
        )

        return exercises
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"生成习题失败: {str(e)}"
        )


@router.get("/{course_id}", response_model=List[ExerciseResponse])
async def list_exercises(
        course_id: int,
        current_user: Teacher = Depends(get_current_teacher)
):
    """获取课程习题列表"""
    exercises = await CourseExercise.filter(course_id=course_id).all()
    return exercises


@router.get("/{course_id}/{exercise_id}", response_model=ExerciseResponse)
async def get_exercise(
        course_id: int,
        exercise_id: int,
        current_user: Teacher = Depends(get_current_teacher)
):
    """获取习题详情"""
    exercise = await CourseExercise.filter(id=exercise_id, course_id=course_id).first()
    if not exercise:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="习题不存在"
        )
    return exercise
```

## 5. 创建数据模型Schema

```python
# server/app/schemas/exercise.py
from typing import List, Dict, Any, Optional
from pydantic import BaseModel
from enum import IntEnum
from datetime import datetime

class ExerciseType(IntEnum):
    CHOICE = 1
    FILL_BLANK = 2
    SHORT_ANSWER = 3

class ExerciseBase(BaseModel):
    title: str
    content: str
    answer: str
    explanation: Optional[str] = None
    type: ExerciseType
    options: Optional[Dict[str, str]] = None

class ExerciseCreate(ExerciseBase):
    course_id: int
    notification_id: Optional[int] = None

class ExerciseResponse(ExerciseBase):
    id: int
    course_id: int
    creator_id: int
    notification_id: Optional[int] = None
    created_at: datetime
    updated_at: datetime
    
    class Config:
        orm_mode = True

class ExerciseGenerateRequest(BaseModel):
    content: str
    exercise_types: Optional[List[ExerciseType]] = None
    count: Optional[int] = 5
    notification_id: Optional[int] = None
```

## 6. 注册路由

在主路由文件中注册习题路由：

```python
# server/app/api/api.py
from fastapi import APIRouter
from app.api.endpoints import exercises

api_router = APIRouter()
# 其他路由...
api_router.include_router(exercises.router, prefix="/courses", tags=["exercises"])
```

## 7. 配置OpenAI API密钥

```python
# server/app/core/config.py
class Settings:
    # 其他配置...
    OPENAI_API_KEY: str = os.getenv("OPENAI_API_KEY", "")

settings = Settings()
```

## 8. 添加环境变量

在项目根目录创建或更新 `.env` 文件：

```
OPENAI_API_KEY=your-api-key-here
```

## 9. 使用向量数据库增强生成质量 (可选)

如果想实现RAG功能，可以添加ChromaDB向量存储：

```python
# server/app/services/vector_store.py
import chromadb
from chromadb.utils import embedding_functions
import re

class VectorStore:
    def __init__(self):
        self.client = chromadb.Client()
        self.embedding_function = embedding_functions.SentenceTransformerEmbeddingFunction()
        self.collection = self.client.create_collection(
            name="course_materials",
            embedding_function=self.embedding_function
        )
    
    def add_document(self, document_id: str, content: str, metadata=None):
        """添加文档到向量数据库"""
        # 将文档分成段落
        paragraphs = self._split_into_paragraphs(content)
        
        ids = [f"{document_id}_para_{i}" for i in range(len(paragraphs))]
        metadatas = [{"source": document_id, **metadata} if metadata else {"source": document_id} for _ in paragraphs]
        
        self.collection.add(
            documents=paragraphs,
            ids=ids,
            metadatas=metadatas
        )
        
    def search(self, query: str, n_results: int = 3):
        """搜索相关内容"""
        results = self.collection.query(
            query_texts=[query],
            n_results=n_results
        )
        
        if results and 'documents' in results and len(results['documents']) > 0:
            return results['documents'][0]
        return []
    
    def _split_into_paragraphs(self, text: str, max_length: int = 1000):
        """将文本分割成段落"""
        # 先按自然段分割
        paragraphs = re.split(r'\n\s*\n', text)
        
        # 处理过长的段落
        result = []
        for para in paragraphs:
            if len(para) <= max_length:
                result.append(para.strip())
            else:
                # 按句子分割过长段落
                sentences = re.split(r'(?<=[.!?])\s+', para)
                current = ""
                for sentence in sentences:
                    if len(current) + len(sentence) <= max_length:
                        current += " " + sentence if current else sentence
                    else:
                        result.append(current.strip())
                        current = sentence
                if current:
                    result.append(current.strip())
        
        return result
```

## 10. 集成向量数据库到习题生成器

更新 `ExerciseGenerator` 类以使用向量库：

```python
# 在 exercise_generator_rt.py 中添加
from app.services.vector_store import VectorStore

class ExerciseGenerator:
    def __init__(self):
        # 现有代码...
        self.vector_store = VectorStore()
    
    # 增加添加教材内容的方法
    async def add_course_material(self, course_id: int, title: str, content: str):
        """添加课程教材到向量库"""
        document_id = f"course_{course_id}_{title}"
        self.vector_store.add_document(
            document_id=document_id,
            content=content,
            metadata={"course_id": course_id, "title": title}
        )
    
    async def generate_exercises(self, ...):
        # 现有代码基础上修改
        
        # 查询相关知识点
        relevant_materials = self.vector_store.search(content, n_results=3)
        
        # 增强提示词
        enhanced_content = content
        if relevant_materials:
            enhanced_content = f"{content}\n\n相关知识点:\n" + "\n---\n".join(relevant_materials)
        
        # 使用增强后的内容构建提示词
        prompt = self._build_prompt(enhanced_content, exercise_types, count)
        
        # 后续代码不变...
```

## 总结

以上就是智能习题生成器的实现方案。流程如下：

1. 教师上传课程材料或提供知识点描述
2. 系统将材料分块存储到向量数据库中
3. 教师请求生成习题时，系统检索相关材料，增强输入内容
4. 调用OpenAI API生成习题
5. 保存习题到数据库并返回给用户

后续可以添加评估习题质量的功能，以及学生答题和错题收集的功能，进一步提升智能教学体验。