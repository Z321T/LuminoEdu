# 智能习题生成器实现方案

基于你现有的课程通知系统，实现智能习题生成器需要完成以下几个部分：

## 1. 创建习题相关数据模型

首先需要在 `server/app/models` 目录下创建 `course_exercise.py` 文件：

```python
# server/app/models/exercise.py
from enum import IntEnum
from tortoise import fields, models

class ExerciseType(IntEnum):
    """习题类型枚举"""
    CHOICE = 1      # 选择题
    FILL_BLANK = 2  # 填空题
    SHORT_ANSWER = 3 # 简答题

class CourseExercise(models.Model):
    """课程习题模型"""
    id = fields.IntField(pk=True)
    title = fields.CharField(max_length=200, description="习题标题")
    content = fields.TextField(description="习题内容")
    answer = fields.TextField(description="参考答案")
    explanation = fields.TextField(null=True, description="解析")
    type = fields.IntEnumField(ExerciseType, description="习题类型")
    
    # 存储选择题选项，JSON格式
    options = fields.JSONField(null=True, description="选择题选项")
    
    # 关联课程
    course = fields.ForeignKeyField(
        "models.Course", related_name="exercises",
        on_delete=fields.CASCADE, description="所属课程"
    )
    
    # 关联通知(可选)
    notification = fields.ForeignKeyField(
        "models.CourseNotification", related_name="exercises",
        on_delete=fields.SET_NULL, null=True, description="关联通知"
    )
    
    # 创建者（教师）
    creator = fields.ForeignKeyField(
        "models.Teacher", related_name="created_exercises",
        on_delete=fields.SET_NULL, null=True, description="创建者"
    )
    
    created_at = fields.DatetimeField(auto_now_add=True, description="创建时间")
    updated_at = fields.DatetimeField(auto_now=True, description="更新时间")
    
    class Meta:
        table = "course_exercises"
        table_description = "课程习题表"
```

## 2. 更新模型导入

在 `server/app/models/__init__.py` 文件中添加新模型：

```python
# 导入所有模型
from .course import Course, CourseStudent, CourseStatus
from .student import Student
from .teacher import Teacher
from .admin import Admin
from .course_notification import CourseNotification, CourseNotificationRead, NotificationType
from .course_exercise import CourseExercise, ExerciseType

# 导出所有模型
__all__ = [
    'Course', 'CourseStudent', 'CourseStatus',
    'Student',
    'Teacher',
    'Admin',
    'CourseNotification', 'CourseNotificationRead', 'NotificationType',
    'CourseExercise', 'ExerciseType'
]
```

## 3. 创建请求与响应的数据模式

在 `server/app/schemas` 目录下创建 `exercise.py` 文件：

```python
# server/app/schemas/exercise.py
from typing import List, Dict, Any, Optional
from pydantic import BaseModel
from enum import IntEnum
from datetime import datetime

class ExerciseType(IntEnum):
    CHOICE = 1
    FILL_BLANK = 2
    SHORT_ANSWER = 3

class ExerciseBase(BaseModel):
    title: str
    content: str
    type: ExerciseType

class ExerciseCreate(ExerciseBase):
    answer: str
    explanation: Optional[str] = None
    options: Optional[List[str]] = None
    course_id: int
    notification_id: Optional[int] = None

class ExerciseGenRequest(BaseModel):
    content: str  # 用于生成习题的课程内容
    count: int = 5  # 生成习题数量
    types: List[ExerciseType] = [ExerciseType.CHOICE, ExerciseType.FILL_BLANK]  # 习题类型
    course_id: int
    notification_id: Optional[int] = None

class ExerciseResponse(ExerciseBase):
    id: int
    answer: str
    explanation: Optional[str] = None
    options: Optional[List[str]] = None
    course_id: int
    creator_id: Optional[int] = None
    notification_id: Optional[int] = None
    created_at: datetime
    updated_at: datetime
    
    class Config:
        orm_mode = True
```

## 4. 创建习题生成服务

在 `server/app/services` 目录下创建 `exercise_generator.py` 文件：

```python
# server/app/services/exercise_generator_rt.py
import openai
import json
import os
from typing import List, Dict, Any
from app.models import CourseExercise, ExerciseType, Course, Teacher
from app.core.config import settings

class ExerciseGenerator:
    """习题生成器服务"""
    
    def __init__(self):
        # 设置 OpenAI API 密钥
        openai.api_key = settings.OPENAI_API_KEY
    
    async def generate_exercises(
        self,
        course_id: int,
        teacher_id: int,
        content: str,
        count: int = 5,
        types: List[ExerciseType] = None,
        notification_id: int = None
    ) -> List[CourseExercise]:
        """
        根据内容生成习题
        
        参数:
            course_id: 课程ID
            teacher_id: 教师ID
            content: 用于生成习题的内容
            count: 生成习题数量
            types: 习题类型列表
            notification_id: 关联通知ID
        
        返回:
            生成的习题列表
        """
        if not types:
            types = [ExerciseType.CHOICE, ExerciseType.FILL_BLANK]
        
        # 获取课程和教师实例
        course = await Course.get(id=course_id)
        teacher = await Teacher.get(id=teacher_id)
        
        # 构建提示词
        prompt = self._build_prompt(content, types, count)
        
        # 调用 AI 模型
        response = await self._call_openai_api(prompt)
        
        # 解析响应
        exercises_data = self._parse_response(response)
        
        # 创建习题记录
        result = []
        for data in exercises_data:
            exercise = await CourseExercise.create(
                title=data.get("title", f"习题{len(result)+1}"),
                content=data.get("content", ""),
                answer=data.get("answer", ""),
                explanation=data.get("explanation", ""),
                type=data.get("type", ExerciseType.CHOICE),
                options=data.get("options"),
                course=course,
                creator=teacher,
                notification_id=notification_id
            )
            result.append(exercise)
        
        return result
    
    def _build_prompt(self, content: str, types: List[ExerciseType], count: int) -> str:
        """构建提示词"""
        types_desc = []
        for t in types:
            if t == ExerciseType.CHOICE:
                types_desc.append("选择题（包含4个选项）")
            elif t == ExerciseType.FILL_BLANK:
                types_desc.append("填空题")
            elif t == ExerciseType.SHORT_ANSWER:
                types_desc.append("简答题")
        
        type_str = "、".join(types_desc)
        
        return f"""
请根据以下教学内容，生成{count}道{type_str}。每道题目需要包含：
1. 题目标题
2. 题目内容
3. 正确答案
4. 答案解析

对于选择题，请提供4个选项（A、B、C、D）。

教学内容：
{content}

请以JSON格式返回，格式如下：
[
  {{
    "title": "题目标题",
    "content": "题目内容",
    "type": 1,  // 1=选择题, 2=填空题, 3=简答题
    "options": ["选项A", "选项B", "选项C", "选项D"],  // 选择题必须
    "answer": "正确答案",
    "explanation": "解析说明"
  }}
  // 其他题目...
]

只返回JSON数据，不要有其他说明文字。
"""
    
    async def _call_openai_api(self, prompt: str) -> str:
        """调用OpenAI API"""
        try:
            response = await openai.ChatCompletion.acreate(
                model="gpt-3.5-turbo",
                messages=[
                    {"role": "system", "content": "你是一位专业的教育教学助手，善于创建高质量的教学习题。"},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.7,
                max_tokens=2000
            )
            return response.choices[0].message["content"]
        except Exception as e:
            print(f"调用AI API出错: {str(e)}")
            # 返回空列表避免程序崩溃
            return "[]"
    
    def _parse_response(self, response: str) -> List[Dict[str, Any]]:
        """解析API响应为习题数据"""
        try:
            # 提取JSON部分（防止API返回额外文本）
            import re
            json_match = re.search(r'\[\s*\{.*\}\s*\]', response, re.DOTALL)
            if json_match:
                json_str = json_match.group(0)
                return json.loads(json_str)
            return []
        except json.JSONDecodeError:
            print("解析习题数据失败")
            return []
```

## 5. 添加配置项

在 `server/app/core/config.py` 文件中添加 OpenAI API 密钥配置：

```python
# 添加到现有的配置类中
class Settings:
    # 其他配置...
    
    # OpenAI API配置
    OPENAI_API_KEY: str = os.getenv("OPENAI_API_KEY", "")
```

## 6. 创建路由处理器

在 `server/app/routers` 目录下创建 `exercises.py` 文件：

```python
# server/app/routers/exercises.py
from fastapi import APIRouter, Depends, HTTPException, status
from typing import List, Optional

from app.models import CourseExercise, Teacher
from app.schemas.exercise import (
    ExerciseCreate,
    ExerciseResponse,
    ExerciseGenRequest
)
from app.core.auth import get_current_teacher
from app.services.teacher.exercise_generator_svc import ExerciseGenerator

router = APIRouter(
    prefix="/exercises",
    tags=["课程习题"]
)

# 实例化习题生成器
exercise_generator = ExerciseGenerator()


@router.post("/generate", response_model=List[ExerciseResponse], description="AI生成习题")
async def generate_exercises(
        request: ExerciseGenRequest,
        current_user: Teacher = Depends(get_current_teacher)
):
    """根据内容生成习题"""
    try:
        exercises = await exercise_generator.generate_exercises(
            course_id=request.course_id,
            teacher_id=current_user.id,
            content=request.content,
            count=request.count,
            types=request.types,
            notification_id=request.notification_id
        )
        return exercises
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"生成习题失败: {str(e)}"
        )


@router.post("/", response_model=ExerciseResponse, description="手动创建习题")
async def create_exercise(
        exercise: ExerciseCreate,
        current_user: Teacher = Depends(get_current_teacher)
):
    """手动创建习题"""
    try:
        new_exercise = await CourseExercise.create(
            title=exercise.title,
            content=exercise.content,
            answer=exercise.answer,
            explanation=exercise.explanation,
            type=exercise.type,
            options=exercise.options,
            course_id=exercise.course_id,
            creator_id=current_user.id,
            notification_id=exercise.notification_id
        )
        return await ExerciseResponse.from_tortoise_orm(new_exercise)
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"创建习题失败: {str(e)}"
        )


@router.get("/course/{course_id}", response_model=List[ExerciseResponse], description="获取课程习题")
async def list_course_exercises(course_id: int):
    """获取课程的所有习题"""
    exercises = await CourseExercise.filter(course_id=course_id).all()
    return exercises


@router.get("/{exercise_id}", response_model=ExerciseResponse, description="获取习题详情")
async def get_exercise(exercise_id: int):
    """获取单个习题详情"""
    exercise = await CourseExercise.get_or_none(id=exercise_id)
    if not exercise:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="习题不存在"
        )
    return exercise
```

## 7. 注册路由

在主路由文件 `server/app/main.py` 或 API 注册文件中添加新路由：

```python
# 更新路由注册
from app.routers import exercises

# 注册路由
app.include_router(exercises.router)
```

## 8. 扩展功能：使用 RAG 增强习题质量（可选）

为了提高习题生成质量，可以添加 RAG（检索增强生成）功能。首先安装必要的库：

```bash
pip install chromadb sentence-transformers
```

然后创建向量存储服务：

```python
# server/app/services/vector_store.py
import chromadb
from chromadb.utils import embedding_functions
import re
from typing import List, Dict, Any

class VectorStore:
    """向量存储服务，用于存储和检索教学内容"""
    
    def __init__(self):
        # 初始化向量数据库
        self.client = chromadb.Client()
        self.embedding_function = embedding_functions.SentenceTransformerEmbeddingFunction()
        # 创建课程内容集合
        self.collection = self.client.get_or_create_collection(
            name="course_materials",
            embedding_function=self.embedding_function
        )
    
    def add_document(self, doc_id: str, content: str, metadata: Dict[str, Any] = None):
        """
        添加文档到向量存储
        
        参数:
            doc_id: 文档ID
            content: 文档内容
            metadata: 文档元数据
        """
        # 将内容分割为多个段落
        chunks = self._split_content(content)
        
        # 为每个段落生成ID
        ids = [f"{doc_id}_chunk_{i}" for i in range(len(chunks))]
        
        # 为每个段落添加相同的元数据
        metadatas = [metadata or {}] * len(chunks)
        
        # 添加到集合
        self.collection.add(
            documents=chunks,
            ids=ids,
            metadatas=metadatas
        )
    
    def search(self, query: str, n_results: int = 3) -> List[str]:
        """
        搜索相关内容
        
        参数:
            query: 搜索查询
            n_results: 返回结果数量
            
        返回:
            匹配的文档片段列表
        """
        results = self.collection.query(
            query_texts=[query],
            n_results=n_results
        )
        
        if results and 'documents' in results and len(results['documents']) > 0:
            return results['documents'][0]
        return []
    
    def _split_content(self, content: str, chunk_size: int = 500) -> List[str]:
        """
        将内容分割为多个片段
        
        参数:
            content: 要分割的内容
            chunk_size: 每个片段的最大长度
            
        返回:
            内容片段列表
        """
        # 首先按段落分割
        paragraphs = re.split(r'\n\s*\n', content)
        
        chunks = []
        current_chunk = ""
        
        for para in paragraphs:
            para = para.strip()
            if not para:
                continue
                
            # 如果段落加上当前块不超过限制，则添加到当前块
            if len(current_chunk) + len(para) <= chunk_size:
                current_chunk = current_chunk + "\n\n" + para if current_chunk else para
            else:
                # 否则保存当前块并开始新块
                if current_chunk:
                    chunks.append(current_chunk)
                current_chunk = para
        
        # 添加最后一个块
        if current_chunk:
            chunks.append(current_chunk)
            
        return chunks
```

然后扩展习题生成器以使用向量存储：

```python
# 更新 server/app/services/exercise_generator_rt.py

from app.services.vector_store import VectorStore

class ExerciseGenerator:
    def __init__(self):
        # 现有代码...
        openai.api_key = settings.OPENAI_API_KEY
        # 添加向量存储
        self.vector_store = VectorStore()
    
    # 添加上传课程材料的方法
    async def add_course_material(self, course_id: int, title: str, content: str):
        """
        添加课程材料到向量存储
        
        参数:
            course_id: 课程ID
            title: 材料标题
            content: 材料内容
        """
        doc_id = f"course_{course_id}_{title}"
        self.vector_store.add_document(
            doc_id=doc_id,
            content=content,
            metadata={"course_id": course_id, "title": title}
        )
    
    # 更新生成方法以使用RAG
    async def generate_exercises(self, course_id, teacher_id, content, count, types, notification_id):
        # 使用向量存储检索相关内容
        relevant_contents = self.vector_store.search(content, n_results=3)
        
        # 增强提示词
        enhanced_content = content
        if relevant_contents:
            enhanced_content = f"{content}\n\n相关知识点:\n" + "\n---\n".join(relevant_contents)
        
        # 使用增强后的内容构建提示词
        prompt = self._build_prompt(enhanced_content, types, count)
        
        # 后续代码不变...
```

## 9. 实施步骤与优化建议

1. **循序渐进实现**：
   - 首先实现基础模型和API
   - 测试与OpenAI API的连接
   - 添加RAG功能提升质量
   - 优化生成的习题格式和质量

2. **环境变量配置**：
   - 在 `.env` 文件中设置 `OPENAI_API_KEY`
   - 确保配置在部署时正确加载

3. **错误处理**：
   - 添加完善的异常处理，特别是API调用失败的情况
   - 提供用户友好的错误信息

4. **性能优化**：
   - 对于大量习题生成，考虑使用后台任务处理
   - 实现缓存机制，避免重复生成相似习题

5. **内容质量控制**：
   - 为教师提供编辑和审核生成习题的功能
   - 收集习题使用反馈来改进生成质量

这个智能习题生成器充分利用了你现有的课程通知系统架构，与课程和教师模型无缝集成，可以作为教师发布课程通知时的增值功能，提供自动化的习题生成能力。